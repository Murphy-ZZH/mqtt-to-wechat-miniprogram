{"version":3,"sources":["index.js","dist/gcoord.cjs.prod.js","dist/gcoord.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA","file":"index.js","sourcesContent":["\n\nif (typeof process === 'undefined' || process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/gcoord.cjs.prod.js');\n} else {\n  module.exports = require('./dist/gcoord.cjs.js');\n}\n","/**\n * @preserve\n * gcoord 1.0.6, geographic coordinate library\n * Copyright (c) 2024 Jiulong Hu <me@hujiulong.com>\n */\n\n\nconst { sin: sin$1, cos: cos$1, sqrt: sqrt$1, abs: abs$1, PI: PI$1 } = Math;\nconst a = 6378245;\nconst ee = 0.006693421622965823;\n// roughly check whether coordinates are in China.\nfunction isInChinaBbox(lon, lat) {\n    return lon >= 72.004 && lon <= 137.8347 && lat >= 0.8293 && lat <= 55.8271;\n}\nfunction transformLat(x, y) {\n    let ret = -100 + 2 * x + 3 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt$1(abs$1(x));\n    ret += ((20 * sin$1(6 * x * PI$1) + 20 * sin$1(2 * x * PI$1)) * 2) / 3;\n    ret += ((20 * sin$1(y * PI$1) + 40 * sin$1((y / 3) * PI$1)) * 2) / 3;\n    ret += ((160 * sin$1((y / 12) * PI$1) + 320 * sin$1((y * PI$1) / 30)) * 2) / 3;\n    return ret;\n}\nfunction transformLon(x, y) {\n    let ret = 300 + x + 2 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt$1(abs$1(x));\n    ret += ((20 * sin$1(6 * x * PI$1) + 20 * sin$1(2 * x * PI$1)) * 2) / 3;\n    ret += ((20 * sin$1(x * PI$1) + 40 * sin$1((x / 3) * PI$1)) * 2) / 3;\n    ret += ((150 * sin$1((x / 12) * PI$1) + 300 * sin$1((x / 30) * PI$1)) * 2) / 3;\n    return ret;\n}\nfunction delta(lon, lat) {\n    let dLon = transformLon(lon - 105, lat - 35);\n    let dLat = transformLat(lon - 105, lat - 35);\n    const radLat = (lat / 180) * PI$1;\n    let magic = sin$1(radLat);\n    magic = 1 - ee * magic * magic;\n    const sqrtMagic = sqrt$1(magic);\n    dLon = (dLon * 180) / ((a / sqrtMagic) * cos$1(radLat) * PI$1);\n    dLat = (dLat * 180) / (((a * (1 - ee)) / (magic * sqrtMagic)) * PI$1);\n    return [dLon, dLat];\n}\nfunction WGS84ToGCJ02(coord) {\n    const [lon, lat] = coord;\n    if (!isInChinaBbox(lon, lat))\n        return [lon, lat];\n    const d = delta(lon, lat);\n    return [lon + d[0], lat + d[1]];\n}\nfunction GCJ02ToWGS84(coord) {\n    const [lon, lat] = coord;\n    if (!isInChinaBbox(lon, lat))\n        return [lon, lat];\n    let [wgsLon, wgsLat] = [lon, lat];\n    let tempPoint = WGS84ToGCJ02([wgsLon, wgsLat]);\n    let dx = tempPoint[0] - lon;\n    let dy = tempPoint[1] - lat;\n    while (abs$1(dx) > 1e-6 || abs$1(dy) > 1e-6) {\n        wgsLon -= dx;\n        wgsLat -= dy;\n        tempPoint = WGS84ToGCJ02([wgsLon, wgsLat]);\n        dx = tempPoint[0] - lon;\n        dy = tempPoint[1] - lat;\n    }\n    return [wgsLon, wgsLat];\n}\n\nconst { sin, cos, atan2, sqrt, PI } = Math;\nconst baiduFactor = (PI * 3000.0) / 180.0;\nfunction BD09ToGCJ02(coord) {\n    const [lon, lat] = coord;\n    const x = lon - 0.0065;\n    const y = lat - 0.006;\n    const z = sqrt(x * x + y * y) - 0.00002 * sin(y * baiduFactor);\n    const theta = atan2(y, x) - 0.000003 * cos(x * baiduFactor);\n    const newLon = z * cos(theta);\n    const newLat = z * sin(theta);\n    return [newLon, newLat];\n}\nfunction GCJ02ToBD09(coord) {\n    const [lon, lat] = coord;\n    const x = lon;\n    const y = lat;\n    const z = sqrt(x * x + y * y) + 0.00002 * sin(y * baiduFactor);\n    const theta = atan2(y, x) + 0.000003 * cos(x * baiduFactor);\n    const newLon = z * cos(theta) + 0.0065;\n    const newLat = z * sin(theta) + 0.006;\n    return [newLon, newLat];\n}\n\n// https://github.com/Turfjs/turf/blob/master/packages/turf-projection/index.ts\nconst R2D = 180 / Math.PI;\nconst D2R = Math.PI / 180;\nconst A = 6378137.0;\nconst MAXEXTENT = 20037508.342789244;\nfunction ESPG3857ToWGS84(xy) {\n    return [\n        (xy[0] * R2D) / A,\n        (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D,\n    ];\n}\nfunction WGS84ToEPSG3857(lonLat) {\n    // compensate longitudes passing the 180th meridian\n    // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js\n    const adjusted = Math.abs(lonLat[0]) <= 180\n        ? lonLat[0]\n        : lonLat[0] - (lonLat[0] < 0 ? -1 : 1) * 360;\n    const xy = [\n        A * adjusted * D2R,\n        A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R)),\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent\n    if (xy[0] > MAXEXTENT)\n        xy[0] = MAXEXTENT;\n    if (xy[0] < -MAXEXTENT)\n        xy[0] = -MAXEXTENT;\n    if (xy[1] > MAXEXTENT)\n        xy[1] = MAXEXTENT;\n    if (xy[1] < -MAXEXTENT)\n        xy[1] = -MAXEXTENT;\n    return xy;\n}\n\nconst { abs } = Math;\nconst MCBAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];\nconst LLBAND = [75, 60, 45, 30, 15, 0];\nconst MC2LL = [\n    [\n        1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331,\n        200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339,\n        2.57121317296198, -0.03801003308653, 17337981.2,\n    ],\n    [\n        -7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289,\n        96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737,\n        -16.50741931063887, 2.28786674699375, 10260144.86,\n    ],\n    [\n        -3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616,\n        59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908,\n        -3.29883767235584, 0.32710905363475, 6856817.37,\n    ],\n    [\n        -1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591,\n        40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263,\n        0.12923347998204, -0.04625736007561, 4482777.06,\n    ],\n    [\n        3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062,\n        23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273,\n        0.03430082397953, -0.00466043876332, 2555164.4,\n    ],\n    [\n        2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8,\n        7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596,\n        0.00010322952773, -0.00000323890364, 826088.5,\n    ],\n];\nconst LL2MC = [\n    [\n        -0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340,\n        26112667856603880, -35149669176653700, 26595700718403920,\n        -10725012454188240, 1800819912950474, 82.5,\n    ],\n    [\n        0.0008277824516172526, 111320.7020463578, 647795574.6671607,\n        -4082003173.641316, 10774905663.51142, -15171875531.51559,\n        12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5,\n    ],\n    [\n        0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662,\n        79682215.47186455, -115964993.2797253, 97236711.15602145,\n        -43661946.33752821, 8477230.501135234, 52.5,\n    ],\n    [\n        0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245,\n        992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312,\n        144416.9293806241, 37.5,\n    ],\n    [\n        -0.0003441963504368392, 111320.7020576856, 278.2353980772752,\n        2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236,\n        -2710.55326746645, 1405.483844121726, 22.5,\n    ],\n    [\n        -0.0003218135878613132, 111320.7020701615, 0.00369383431289,\n        823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199,\n        8.77738589078284, 0.37238884252424, 7.45,\n    ],\n];\nfunction transform$1(x, y, factors) {\n    const cc = abs(y) / factors[9];\n    let xt = factors[0] + factors[1] * abs(x);\n    let yt = factors[2] +\n        factors[3] * cc +\n        factors[4] * Math.pow(cc, 2) +\n        factors[5] * Math.pow(cc, 3) +\n        factors[6] * Math.pow(cc, 4) +\n        factors[7] * Math.pow(cc, 5) +\n        factors[8] * Math.pow(cc, 6);\n    xt *= x < 0 ? -1 : 1;\n    yt *= y < 0 ? -1 : 1;\n    return [xt, yt];\n}\nfunction BD09toBD09MC(coord) {\n    const [lng, lat] = coord;\n    let factors = [];\n    for (let i = 0; i < LLBAND.length; i++) {\n        if (abs(lat) > LLBAND[i]) {\n            factors = LL2MC[i];\n            break;\n        }\n    }\n    return transform$1(lng, lat, factors);\n}\nfunction BD09MCtoBD09(coord) {\n    const [x, y] = coord;\n    let factors = [];\n    for (let i = 0; i < MCBAND.length; i++) {\n        if (y >= MCBAND[i]) {\n            factors = MC2LL[i];\n            break;\n        }\n    }\n    return transform$1(x, y, factors);\n}\n\nfunction assert(condition, msg) {\n    if (!condition)\n        throw new Error(msg);\n}\n/**\n * isArray\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n */\nfunction isArray(input) {\n    return !!input && Object.prototype.toString.call(input) === '[object Array]';\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * isNumber(123)\n * //=true\n * isNumber('foo')\n * //=false\n */\nfunction isNumber(input) {\n    return !isNaN(Number(input)) && input !== null && !isArray(input);\n}\n/**\n * compose\n */\nfunction compose(...funcs) {\n    const start = funcs.length - 1;\n    /* eslint-disable func-names */\n    return function (...args) {\n        let i = start;\n        let result = funcs[start].apply(null, args);\n        while (i--)\n            result = funcs[i].call(null, result);\n        return result;\n    };\n}\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n * https://github.com/Turfjs/turf/blob/master/packages/turf-meta/index.mjs\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * let features = featureCollection([\n *   point([26, 37], {\"foo\": \"bar\"}),\n *   point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n/* eslint-disable no-param-reassign */\nfunction coordEach(geojson, callback, excludeWrapCoord = false) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null)\n        return;\n    /* eslint-disable-next-line */\n    let j;\n    let k;\n    let l;\n    let geometry;\n    let coords;\n    let stopG;\n    let wrapShrink = 0;\n    let coordIndex = 0;\n    let geometryMaybeCollection;\n    let isGeometryCollection;\n    const { type } = geojson;\n    const isFeatureCollection = type === 'FeatureCollection';\n    const isFeature = type === 'Feature';\n    const stop = isFeatureCollection\n        ? geojson.features.length\n        : 1;\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (let featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = isFeatureCollection\n            ? geojson.features[featureIndex].geometry\n            : isFeature\n                ? geojson.geometry\n                : geojson;\n        isGeometryCollection = geometryMaybeCollection\n            ? geometryMaybeCollection.type === 'GeometryCollection'\n            : false;\n        stopG = isGeometryCollection\n            ? geometryMaybeCollection.geometries.length\n            : 1;\n        for (let geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            let multiFeatureIndex = 0;\n            let geometryIndex = 0;\n            geometry = isGeometryCollection\n                ? geometryMaybeCollection.geometries[geomIndex]\n                : geometryMaybeCollection;\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null)\n                continue;\n            const geomType = geometry.type;\n            wrapShrink =\n                excludeWrapCoord &&\n                    (geomType === 'Polygon' || geomType === 'MultiPolygon')\n                    ? 1\n                    : 0;\n            switch (geomType) {\n                case null:\n                    break;\n                case 'Point':\n                    coords = geometry.coordinates;\n                    if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                        return false;\n                    coordIndex++;\n                    multiFeatureIndex++;\n                    break;\n                case 'LineString':\n                case 'MultiPoint':\n                    coords = geometry.coordinates;\n                    for (j = 0; j < coords.length; j++) {\n                        if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                            return false;\n                        coordIndex++;\n                        if (geomType === 'MultiPoint')\n                            multiFeatureIndex++;\n                    }\n                    if (geomType === 'LineString')\n                        multiFeatureIndex++;\n                    break;\n                case 'Polygon':\n                case 'MultiLineString':\n                    coords = geometry.coordinates;\n                    for (j = 0; j < coords.length; j++) {\n                        for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                            if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                                return false;\n                            coordIndex++;\n                        }\n                        if (geomType === 'MultiLineString')\n                            multiFeatureIndex++;\n                        if (geomType === 'Polygon')\n                            geometryIndex++;\n                    }\n                    if (geomType === 'Polygon')\n                        multiFeatureIndex++;\n                    break;\n                case 'MultiPolygon':\n                    coords = geometry.coordinates;\n                    for (j = 0; j < coords.length; j++) {\n                        geometryIndex = 0;\n                        for (k = 0; k < coords[j].length; k++) {\n                            for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                                    return false;\n                                coordIndex++;\n                            }\n                            geometryIndex++;\n                        }\n                        multiFeatureIndex++;\n                    }\n                    break;\n                case 'GeometryCollection':\n                    for (j = 0; j < geometry.geometries.length; j++) {\n                        if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n                            return false;\n                    }\n                    break;\n                default:\n                    throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\nvar CRSTypes;\n(function (CRSTypes) {\n    // WGS84\n    CRSTypes[\"WGS84\"] = \"WGS84\";\n    CRSTypes[\"WGS1984\"] = \"WGS84\";\n    CRSTypes[\"EPSG4326\"] = \"WGS84\";\n    // GCJ02\n    CRSTypes[\"GCJ02\"] = \"GCJ02\";\n    CRSTypes[\"AMap\"] = \"GCJ02\";\n    // BD09\n    CRSTypes[\"BD09\"] = \"BD09\";\n    CRSTypes[\"BD09LL\"] = \"BD09\";\n    CRSTypes[\"Baidu\"] = \"BD09\";\n    CRSTypes[\"BMap\"] = \"BD09\";\n    // BD09MC\n    CRSTypes[\"BD09MC\"] = \"BD09MC\";\n    CRSTypes[\"BD09Meter\"] = \"BD09MC\";\n    // EPSG3857\n    CRSTypes[\"EPSG3857\"] = \"EPSG3857\";\n    CRSTypes[\"EPSG900913\"] = \"EPSG3857\";\n    CRSTypes[\"EPSG102100\"] = \"EPSG3857\";\n    CRSTypes[\"WebMercator\"] = \"EPSG3857\";\n    CRSTypes[\"WM\"] = \"EPSG3857\";\n})(CRSTypes || (CRSTypes = {}));\nconst WGS84 = {\n    to: {\n        [CRSTypes.GCJ02]: WGS84ToGCJ02,\n        [CRSTypes.BD09]: compose(GCJ02ToBD09, WGS84ToGCJ02),\n        [CRSTypes.BD09MC]: compose(BD09toBD09MC, GCJ02ToBD09, WGS84ToGCJ02),\n        [CRSTypes.EPSG3857]: WGS84ToEPSG3857,\n    },\n};\nconst GCJ02 = {\n    to: {\n        [CRSTypes.WGS84]: GCJ02ToWGS84,\n        [CRSTypes.BD09]: GCJ02ToBD09,\n        [CRSTypes.BD09MC]: compose(BD09toBD09MC, GCJ02ToBD09),\n        [CRSTypes.EPSG3857]: compose(WGS84ToEPSG3857, GCJ02ToWGS84),\n    },\n};\nconst BD09 = {\n    to: {\n        [CRSTypes.WGS84]: compose(GCJ02ToWGS84, BD09ToGCJ02),\n        [CRSTypes.GCJ02]: BD09ToGCJ02,\n        [CRSTypes.EPSG3857]: compose(WGS84ToEPSG3857, GCJ02ToWGS84, BD09ToGCJ02),\n        [CRSTypes.BD09MC]: BD09toBD09MC,\n    },\n};\nconst EPSG3857 = {\n    to: {\n        [CRSTypes.WGS84]: ESPG3857ToWGS84,\n        [CRSTypes.GCJ02]: compose(WGS84ToGCJ02, ESPG3857ToWGS84),\n        [CRSTypes.BD09]: compose(GCJ02ToBD09, WGS84ToGCJ02, ESPG3857ToWGS84),\n        [CRSTypes.BD09MC]: compose(BD09toBD09MC, GCJ02ToBD09, WGS84ToGCJ02, ESPG3857ToWGS84),\n    },\n};\nconst BD09MC = {\n    to: {\n        [CRSTypes.WGS84]: compose(GCJ02ToWGS84, BD09ToGCJ02, BD09MCtoBD09),\n        [CRSTypes.GCJ02]: compose(BD09ToGCJ02, BD09MCtoBD09),\n        [CRSTypes.EPSG3857]: compose(WGS84ToEPSG3857, GCJ02ToWGS84, BD09ToGCJ02, BD09MCtoBD09),\n        [CRSTypes.BD09]: BD09MCtoBD09,\n    },\n};\nconst crsMap = {\n    WGS84,\n    GCJ02,\n    BD09,\n    EPSG3857,\n    BD09MC,\n};\nvar crsMap$1 = crsMap;\n\n/**\n * transform\n *\n * @param {geojson|position|string} input\n * @returns {geojson|position} output\n */\n/* eslint-disable no-param-reassign */\nfunction transform(input, crsFrom, crsTo) {\n    assert(!!input, 'The args[0] input coordinate is required');\n    assert(!!crsFrom, 'The args[1] original coordinate system is required');\n    assert(!!crsTo, 'The args[2] target coordinate system is required');\n    if (crsFrom === crsTo)\n        return input;\n    const from = crsMap$1[crsFrom];\n    assert(!!from, `Invalid original coordinate system: ${crsFrom}`);\n    const to = from.to[crsTo];\n    assert(!!to, `Invalid target coordinate system: ${crsTo}`);\n    const type = typeof input;\n    assert(type === 'string' || type === 'object', `Invalid input coordinate type: ${type}`);\n    if (type === 'string') {\n        try {\n            input = JSON.parse(input);\n        }\n        catch (e) {\n            throw new Error(`Invalid input coordinate: ${input}`);\n        }\n    }\n    let isPosition = false;\n    if (isArray(input)) {\n        assert(input.length >= 2, `Invalid input coordinate: ${input}`);\n        assert(isNumber(input[0]) && isNumber(input[1]), `Invalid input coordinate: ${input}`);\n        input = input.map(Number);\n        isPosition = true;\n    }\n    const convert = to;\n    if (isPosition)\n        return convert(input);\n    // GeoJSON类型直接转换输入\n    coordEach(input, (coord) => {\n        [coord[0], coord[1]] = convert(coord);\n    });\n    return input;\n}\n\nconst exported = Object.assign(Object.assign({}, CRSTypes), { // 兼容原来gcoord.WGS84的使用方式\n    CRSTypes,\n    transform });\n\nmodule.exports = exported;\n","/**\n * @preserve\n * gcoord 1.0.6, geographic coordinate library\n * Copyright (c) 2024 Jiulong Hu <me@hujiulong.com>\n */\n\n\nconst { sin: sin$1, cos: cos$1, sqrt: sqrt$1, abs: abs$1, PI: PI$1 } = Math;\nconst a = 6378245;\nconst ee = 0.006693421622965823;\n// roughly check whether coordinates are in China.\nfunction isInChinaBbox(lon, lat) {\n    return lon >= 72.004 && lon <= 137.8347 && lat >= 0.8293 && lat <= 55.8271;\n}\nfunction transformLat(x, y) {\n    let ret = -100 + 2 * x + 3 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt$1(abs$1(x));\n    ret += ((20 * sin$1(6 * x * PI$1) + 20 * sin$1(2 * x * PI$1)) * 2) / 3;\n    ret += ((20 * sin$1(y * PI$1) + 40 * sin$1((y / 3) * PI$1)) * 2) / 3;\n    ret += ((160 * sin$1((y / 12) * PI$1) + 320 * sin$1((y * PI$1) / 30)) * 2) / 3;\n    return ret;\n}\nfunction transformLon(x, y) {\n    let ret = 300 + x + 2 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt$1(abs$1(x));\n    ret += ((20 * sin$1(6 * x * PI$1) + 20 * sin$1(2 * x * PI$1)) * 2) / 3;\n    ret += ((20 * sin$1(x * PI$1) + 40 * sin$1((x / 3) * PI$1)) * 2) / 3;\n    ret += ((150 * sin$1((x / 12) * PI$1) + 300 * sin$1((x / 30) * PI$1)) * 2) / 3;\n    return ret;\n}\nfunction delta(lon, lat) {\n    let dLon = transformLon(lon - 105, lat - 35);\n    let dLat = transformLat(lon - 105, lat - 35);\n    const radLat = (lat / 180) * PI$1;\n    let magic = sin$1(radLat);\n    magic = 1 - ee * magic * magic;\n    const sqrtMagic = sqrt$1(magic);\n    dLon = (dLon * 180) / ((a / sqrtMagic) * cos$1(radLat) * PI$1);\n    dLat = (dLat * 180) / (((a * (1 - ee)) / (magic * sqrtMagic)) * PI$1);\n    return [dLon, dLat];\n}\nfunction WGS84ToGCJ02(coord) {\n    const [lon, lat] = coord;\n    if (!isInChinaBbox(lon, lat))\n        return [lon, lat];\n    const d = delta(lon, lat);\n    return [lon + d[0], lat + d[1]];\n}\nfunction GCJ02ToWGS84(coord) {\n    const [lon, lat] = coord;\n    if (!isInChinaBbox(lon, lat))\n        return [lon, lat];\n    let [wgsLon, wgsLat] = [lon, lat];\n    let tempPoint = WGS84ToGCJ02([wgsLon, wgsLat]);\n    let dx = tempPoint[0] - lon;\n    let dy = tempPoint[1] - lat;\n    while (abs$1(dx) > 1e-6 || abs$1(dy) > 1e-6) {\n        wgsLon -= dx;\n        wgsLat -= dy;\n        tempPoint = WGS84ToGCJ02([wgsLon, wgsLat]);\n        dx = tempPoint[0] - lon;\n        dy = tempPoint[1] - lat;\n    }\n    return [wgsLon, wgsLat];\n}\n\nconst { sin, cos, atan2, sqrt, PI } = Math;\nconst baiduFactor = (PI * 3000.0) / 180.0;\nfunction BD09ToGCJ02(coord) {\n    const [lon, lat] = coord;\n    const x = lon - 0.0065;\n    const y = lat - 0.006;\n    const z = sqrt(x * x + y * y) - 0.00002 * sin(y * baiduFactor);\n    const theta = atan2(y, x) - 0.000003 * cos(x * baiduFactor);\n    const newLon = z * cos(theta);\n    const newLat = z * sin(theta);\n    return [newLon, newLat];\n}\nfunction GCJ02ToBD09(coord) {\n    const [lon, lat] = coord;\n    const x = lon;\n    const y = lat;\n    const z = sqrt(x * x + y * y) + 0.00002 * sin(y * baiduFactor);\n    const theta = atan2(y, x) + 0.000003 * cos(x * baiduFactor);\n    const newLon = z * cos(theta) + 0.0065;\n    const newLat = z * sin(theta) + 0.006;\n    return [newLon, newLat];\n}\n\n// https://github.com/Turfjs/turf/blob/master/packages/turf-projection/index.ts\nconst R2D = 180 / Math.PI;\nconst D2R = Math.PI / 180;\nconst A = 6378137.0;\nconst MAXEXTENT = 20037508.342789244;\nfunction ESPG3857ToWGS84(xy) {\n    return [\n        (xy[0] * R2D) / A,\n        (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D,\n    ];\n}\nfunction WGS84ToEPSG3857(lonLat) {\n    // compensate longitudes passing the 180th meridian\n    // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js\n    const adjusted = Math.abs(lonLat[0]) <= 180\n        ? lonLat[0]\n        : lonLat[0] - (lonLat[0] < 0 ? -1 : 1) * 360;\n    const xy = [\n        A * adjusted * D2R,\n        A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R)),\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent\n    if (xy[0] > MAXEXTENT)\n        xy[0] = MAXEXTENT;\n    if (xy[0] < -MAXEXTENT)\n        xy[0] = -MAXEXTENT;\n    if (xy[1] > MAXEXTENT)\n        xy[1] = MAXEXTENT;\n    if (xy[1] < -MAXEXTENT)\n        xy[1] = -MAXEXTENT;\n    return xy;\n}\n\nconst { abs } = Math;\nconst MCBAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];\nconst LLBAND = [75, 60, 45, 30, 15, 0];\nconst MC2LL = [\n    [\n        1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331,\n        200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339,\n        2.57121317296198, -0.03801003308653, 17337981.2,\n    ],\n    [\n        -7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289,\n        96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737,\n        -16.50741931063887, 2.28786674699375, 10260144.86,\n    ],\n    [\n        -3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616,\n        59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908,\n        -3.29883767235584, 0.32710905363475, 6856817.37,\n    ],\n    [\n        -1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591,\n        40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263,\n        0.12923347998204, -0.04625736007561, 4482777.06,\n    ],\n    [\n        3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062,\n        23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273,\n        0.03430082397953, -0.00466043876332, 2555164.4,\n    ],\n    [\n        2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8,\n        7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596,\n        0.00010322952773, -0.00000323890364, 826088.5,\n    ],\n];\nconst LL2MC = [\n    [\n        -0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340,\n        26112667856603880, -35149669176653700, 26595700718403920,\n        -10725012454188240, 1800819912950474, 82.5,\n    ],\n    [\n        0.0008277824516172526, 111320.7020463578, 647795574.6671607,\n        -4082003173.641316, 10774905663.51142, -15171875531.51559,\n        12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5,\n    ],\n    [\n        0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662,\n        79682215.47186455, -115964993.2797253, 97236711.15602145,\n        -43661946.33752821, 8477230.501135234, 52.5,\n    ],\n    [\n        0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245,\n        992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312,\n        144416.9293806241, 37.5,\n    ],\n    [\n        -0.0003441963504368392, 111320.7020576856, 278.2353980772752,\n        2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236,\n        -2710.55326746645, 1405.483844121726, 22.5,\n    ],\n    [\n        -0.0003218135878613132, 111320.7020701615, 0.00369383431289,\n        823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199,\n        8.77738589078284, 0.37238884252424, 7.45,\n    ],\n];\nfunction transform$1(x, y, factors) {\n    const cc = abs(y) / factors[9];\n    let xt = factors[0] + factors[1] * abs(x);\n    let yt = factors[2] +\n        factors[3] * cc +\n        factors[4] * Math.pow(cc, 2) +\n        factors[5] * Math.pow(cc, 3) +\n        factors[6] * Math.pow(cc, 4) +\n        factors[7] * Math.pow(cc, 5) +\n        factors[8] * Math.pow(cc, 6);\n    xt *= x < 0 ? -1 : 1;\n    yt *= y < 0 ? -1 : 1;\n    return [xt, yt];\n}\nfunction BD09toBD09MC(coord) {\n    const [lng, lat] = coord;\n    let factors = [];\n    for (let i = 0; i < LLBAND.length; i++) {\n        if (abs(lat) > LLBAND[i]) {\n            factors = LL2MC[i];\n            break;\n        }\n    }\n    return transform$1(lng, lat, factors);\n}\nfunction BD09MCtoBD09(coord) {\n    const [x, y] = coord;\n    let factors = [];\n    for (let i = 0; i < MCBAND.length; i++) {\n        if (y >= MCBAND[i]) {\n            factors = MC2LL[i];\n            break;\n        }\n    }\n    return transform$1(x, y, factors);\n}\n\nfunction assert(condition, msg) {\n    if (!condition)\n        throw new Error(msg);\n}\n/**\n * isArray\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n */\nfunction isArray(input) {\n    return !!input && Object.prototype.toString.call(input) === '[object Array]';\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * isNumber(123)\n * //=true\n * isNumber('foo')\n * //=false\n */\nfunction isNumber(input) {\n    return !isNaN(Number(input)) && input !== null && !isArray(input);\n}\n/**\n * compose\n */\nfunction compose(...funcs) {\n    const start = funcs.length - 1;\n    /* eslint-disable func-names */\n    return function (...args) {\n        let i = start;\n        let result = funcs[start].apply(null, args);\n        while (i--)\n            result = funcs[i].call(null, result);\n        return result;\n    };\n}\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n * https://github.com/Turfjs/turf/blob/master/packages/turf-meta/index.mjs\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * let features = featureCollection([\n *   point([26, 37], {\"foo\": \"bar\"}),\n *   point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\n/* eslint-disable no-param-reassign */\nfunction coordEach(geojson, callback, excludeWrapCoord = false) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null)\n        return;\n    /* eslint-disable-next-line */\n    let j;\n    let k;\n    let l;\n    let geometry;\n    let coords;\n    let stopG;\n    let wrapShrink = 0;\n    let coordIndex = 0;\n    let geometryMaybeCollection;\n    let isGeometryCollection;\n    const { type } = geojson;\n    const isFeatureCollection = type === 'FeatureCollection';\n    const isFeature = type === 'Feature';\n    const stop = isFeatureCollection\n        ? geojson.features.length\n        : 1;\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (let featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = isFeatureCollection\n            ? geojson.features[featureIndex].geometry\n            : isFeature\n                ? geojson.geometry\n                : geojson;\n        isGeometryCollection = geometryMaybeCollection\n            ? geometryMaybeCollection.type === 'GeometryCollection'\n            : false;\n        stopG = isGeometryCollection\n            ? geometryMaybeCollection.geometries.length\n            : 1;\n        for (let geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            let multiFeatureIndex = 0;\n            let geometryIndex = 0;\n            geometry = isGeometryCollection\n                ? geometryMaybeCollection.geometries[geomIndex]\n                : geometryMaybeCollection;\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null)\n                continue;\n            const geomType = geometry.type;\n            wrapShrink =\n                excludeWrapCoord &&\n                    (geomType === 'Polygon' || geomType === 'MultiPolygon')\n                    ? 1\n                    : 0;\n            switch (geomType) {\n                case null:\n                    break;\n                case 'Point':\n                    coords = geometry.coordinates;\n                    if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                        return false;\n                    coordIndex++;\n                    multiFeatureIndex++;\n                    break;\n                case 'LineString':\n                case 'MultiPoint':\n                    coords = geometry.coordinates;\n                    for (j = 0; j < coords.length; j++) {\n                        if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                            return false;\n                        coordIndex++;\n                        if (geomType === 'MultiPoint')\n                            multiFeatureIndex++;\n                    }\n                    if (geomType === 'LineString')\n                        multiFeatureIndex++;\n                    break;\n                case 'Polygon':\n                case 'MultiLineString':\n                    coords = geometry.coordinates;\n                    for (j = 0; j < coords.length; j++) {\n                        for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                            if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                                return false;\n                            coordIndex++;\n                        }\n                        if (geomType === 'MultiLineString')\n                            multiFeatureIndex++;\n                        if (geomType === 'Polygon')\n                            geometryIndex++;\n                    }\n                    if (geomType === 'Polygon')\n                        multiFeatureIndex++;\n                    break;\n                case 'MultiPolygon':\n                    coords = geometry.coordinates;\n                    for (j = 0; j < coords.length; j++) {\n                        geometryIndex = 0;\n                        for (k = 0; k < coords[j].length; k++) {\n                            for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false)\n                                    return false;\n                                coordIndex++;\n                            }\n                            geometryIndex++;\n                        }\n                        multiFeatureIndex++;\n                    }\n                    break;\n                case 'GeometryCollection':\n                    for (j = 0; j < geometry.geometries.length; j++) {\n                        if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n                            return false;\n                    }\n                    break;\n                default:\n                    throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\nvar CRSTypes;\n(function (CRSTypes) {\n    // WGS84\n    CRSTypes[\"WGS84\"] = \"WGS84\";\n    CRSTypes[\"WGS1984\"] = \"WGS84\";\n    CRSTypes[\"EPSG4326\"] = \"WGS84\";\n    // GCJ02\n    CRSTypes[\"GCJ02\"] = \"GCJ02\";\n    CRSTypes[\"AMap\"] = \"GCJ02\";\n    // BD09\n    CRSTypes[\"BD09\"] = \"BD09\";\n    CRSTypes[\"BD09LL\"] = \"BD09\";\n    CRSTypes[\"Baidu\"] = \"BD09\";\n    CRSTypes[\"BMap\"] = \"BD09\";\n    // BD09MC\n    CRSTypes[\"BD09MC\"] = \"BD09MC\";\n    CRSTypes[\"BD09Meter\"] = \"BD09MC\";\n    // EPSG3857\n    CRSTypes[\"EPSG3857\"] = \"EPSG3857\";\n    CRSTypes[\"EPSG900913\"] = \"EPSG3857\";\n    CRSTypes[\"EPSG102100\"] = \"EPSG3857\";\n    CRSTypes[\"WebMercator\"] = \"EPSG3857\";\n    CRSTypes[\"WM\"] = \"EPSG3857\";\n})(CRSTypes || (CRSTypes = {}));\nconst WGS84 = {\n    to: {\n        [CRSTypes.GCJ02]: WGS84ToGCJ02,\n        [CRSTypes.BD09]: compose(GCJ02ToBD09, WGS84ToGCJ02),\n        [CRSTypes.BD09MC]: compose(BD09toBD09MC, GCJ02ToBD09, WGS84ToGCJ02),\n        [CRSTypes.EPSG3857]: WGS84ToEPSG3857,\n    },\n};\nconst GCJ02 = {\n    to: {\n        [CRSTypes.WGS84]: GCJ02ToWGS84,\n        [CRSTypes.BD09]: GCJ02ToBD09,\n        [CRSTypes.BD09MC]: compose(BD09toBD09MC, GCJ02ToBD09),\n        [CRSTypes.EPSG3857]: compose(WGS84ToEPSG3857, GCJ02ToWGS84),\n    },\n};\nconst BD09 = {\n    to: {\n        [CRSTypes.WGS84]: compose(GCJ02ToWGS84, BD09ToGCJ02),\n        [CRSTypes.GCJ02]: BD09ToGCJ02,\n        [CRSTypes.EPSG3857]: compose(WGS84ToEPSG3857, GCJ02ToWGS84, BD09ToGCJ02),\n        [CRSTypes.BD09MC]: BD09toBD09MC,\n    },\n};\nconst EPSG3857 = {\n    to: {\n        [CRSTypes.WGS84]: ESPG3857ToWGS84,\n        [CRSTypes.GCJ02]: compose(WGS84ToGCJ02, ESPG3857ToWGS84),\n        [CRSTypes.BD09]: compose(GCJ02ToBD09, WGS84ToGCJ02, ESPG3857ToWGS84),\n        [CRSTypes.BD09MC]: compose(BD09toBD09MC, GCJ02ToBD09, WGS84ToGCJ02, ESPG3857ToWGS84),\n    },\n};\nconst BD09MC = {\n    to: {\n        [CRSTypes.WGS84]: compose(GCJ02ToWGS84, BD09ToGCJ02, BD09MCtoBD09),\n        [CRSTypes.GCJ02]: compose(BD09ToGCJ02, BD09MCtoBD09),\n        [CRSTypes.EPSG3857]: compose(WGS84ToEPSG3857, GCJ02ToWGS84, BD09ToGCJ02, BD09MCtoBD09),\n        [CRSTypes.BD09]: BD09MCtoBD09,\n    },\n};\nconst crsMap = {\n    WGS84,\n    GCJ02,\n    BD09,\n    EPSG3857,\n    BD09MC,\n};\nvar crsMap$1 = crsMap;\n\n/**\n * transform\n *\n * @param {geojson|position|string} input\n * @returns {geojson|position} output\n */\n/* eslint-disable no-param-reassign */\nfunction transform(input, crsFrom, crsTo) {\n    assert(!!input, 'The args[0] input coordinate is required');\n    assert(!!crsFrom, 'The args[1] original coordinate system is required');\n    assert(!!crsTo, 'The args[2] target coordinate system is required');\n    if (crsFrom === crsTo)\n        return input;\n    const from = crsMap$1[crsFrom];\n    assert(!!from, `Invalid original coordinate system: ${crsFrom}`);\n    const to = from.to[crsTo];\n    assert(!!to, `Invalid target coordinate system: ${crsTo}`);\n    const type = typeof input;\n    assert(type === 'string' || type === 'object', `Invalid input coordinate type: ${type}`);\n    if (type === 'string') {\n        try {\n            input = JSON.parse(input);\n        }\n        catch (e) {\n            throw new Error(`Invalid input coordinate: ${input}`);\n        }\n    }\n    let isPosition = false;\n    if (isArray(input)) {\n        assert(input.length >= 2, `Invalid input coordinate: ${input}`);\n        assert(isNumber(input[0]) && isNumber(input[1]), `Invalid input coordinate: ${input}`);\n        input = input.map(Number);\n        isPosition = true;\n    }\n    const convert = to;\n    if (isPosition)\n        return convert(input);\n    // GeoJSON类型直接转换输入\n    coordEach(input, (coord) => {\n        [coord[0], coord[1]] = convert(coord);\n    });\n    return input;\n}\n\nconst exported = Object.assign(Object.assign({}, CRSTypes), { // 兼容原来gcoord.WGS84的使用方式\n    CRSTypes,\n    transform });\n\nmodule.exports = exported;\n"]}